#include "Entity.h"

Player::Player(int32_t w, int32_t h, olc::vf2d iPos, float mass = 500.0f)
	: Entity(
		{ float(w) / 2, float(h) / 2 },		// Initial position
		{ 0.0f, 0.0f },					// Initial velocity
		mass,							// Entity mass
		Type::PLAYER) {					// Entity type

	// Movement behavior
	this->setPhysics(250.0f, 50.0f, 0.2f);

	// Initialize camera and camera settings
	cam = new Camera(w, h, -iPos);
	cam->setPanningOptions(stopRadius, accel);

	// Set the boundary of the player based on the camera
	this->updateBoundary({
		// These points are generated by the camera constructor
		cam->getPoint(0).x,
		cam->getPoint(1).x,
		cam->getPoint(0).y,
		cam->getPoint(1).y
		});

	// Set the map boundary
	mapBounds = { 0, float(w), 0, float(h) };
}

Player::~Player()
{
	// Release memory for the camera
	delete cam;
}

// Getters
Camera* Player::getCamera() { return cam; }

// Virtual functions
void Player::updatePosition(float elapsedTime) {

	// Various checks and adjustments to velocity
	this->velDecay();
	this->speedCheck();

	// Update position
	this->increasePos(this->getVel() * elapsedTime);

	this->cameraManip();		// Cool camera effects and illusions
	this->collision();			// Check collision with boundaries

	// Animation
	am->updateAnimation(elapsedTime);
	if (this->getVel().mag2() == 0) {
		am->selectAnimation(0);
		am->idle(200);
	}
}
//void Player::initAnimations(std::vector<int> animationCounts, int framesPerAnimation, std::string file){}

// Public functions
void Player::move(Move m) {

	float speed = this->getSpeed();

	switch (m)
	{
	case Move::UP:
		this->increaseVel({ 0.0f, -speed });
		am->selectAnimation(3);
		break;
	case Move::DOWN:
		this->increaseVel({ 0.0f, speed });
		am->selectAnimation(4);
		break;
	case Move::LEFT:
		this->increaseVel({ -speed, 0.0f });
		am->selectAnimation(2);
		break;
	case Move::RIGHT:
		this->increaseVel({ speed, 0.0f });
		am->selectAnimation(1);
		break;
	default:
		break;
	}

	// Make sure that we play the animation we selected
	am->play();
}

// Private functions
void Player::cameraManip() {

	olc::vf2d pos = this->getPos();

	// Adjust the camera based on current position
	cam->smooth(pos);

	Boundary b = this->getBoundary();

	// Find midpoint
	float midX = (b.xLower + b.xUpper) / 2;
	float midY = (b.yLower + b.yUpper) / 2;
	olc::vf2d midPoint = { midX, midY };

	// Calculate the distance from the midpoint
	olc::vf2d dist = midPoint - pos;

	// Determine how quickly to adjust the position based on distance from the midpoint
	if (dist.mag2() > stopRadius) {
		this->increasePos(dist * accel);
	}
}
void Player::collision() {

	olc::vf2d pos = this->getPos();

	// Prevent player from moving too far from the center of the screen
	Boundary b = this->getBoundary();
	if (pos.x < b.xLower || pos.x > b.xUpper) {
		pos.x < b.xLower ? pos.x = b.xLower : pos.x = b.xUpper;
	}
	if (pos.y < b.yLower || pos.y > b.yUpper) {
		pos.y < b.yLower ? pos.y = b.yLower : pos.y = b.yUpper;
	}

	// Map boundary
	olc::vf2d bounds = cam->getOffsets();
	if (pos.x - bounds.x - r < mapBounds.xLower || pos.x - bounds.x + r > mapBounds.xUpper) {
		pos.x - bounds.x - r < mapBounds.xLower ?
			pos.x = bounds.x + mapBounds.xLower + r : pos.x = bounds.x + mapBounds.xUpper - r;
	}
	if (pos.y - bounds.y - r < mapBounds.yLower || pos.y - bounds.y + r > mapBounds.yUpper) {
		pos.y - bounds.y - r < mapBounds.yLower ?
			pos.y = bounds.y + mapBounds.yLower + r : pos.y = bounds.y + mapBounds.yUpper - r;
	}

	// Apply position corrections
	this->setPos(pos);
}